应用:
系统:Linux的完全公平调度器,高精度计时器,ext3文件系统
Java：TreeMap,TreeSet
      在Java8 中HashMap的实现中也使用了红黑树代替链表而取得不错的性能提升

实现步骤
1. 构建BST(Binary Sort Tree)，手动建树
   1.1 BST概念
       BST是具有下列性质的二叉树
         (1).若左子树不为空，则左子树上所有节点的值均小于它的根节点的值
         (2).若右子树不为空，则右子树上所有节点的值均大于它的根节点的值
         (3).它的左右子树也分别为二叉排序树
       i.e.            45
                     /    \
                    /      \
                   12       53
                  /  \       \
                 3   37       100
                     /        /
                    24       61
                              \
                               90
                               /
                               78
       新增的方法:initBST , displayPreOrder

   1.2 BST 的插入
       构建BST的插入操作，需要先实现BST的查找功能，在插入节点之前先查找该节点是否已经存在，若存在则不需要插入操作
       若不存在，再执行插入操作。新插入的节点一定是叶子节点，并且是查找不成功时查找路径上访问的最后一个节点的左孩子
       或者右孩子，查找功能就是返回查找不成功时返回查找路径上最后访问的节点。

       有了插入功能之后，可以使用插入操作构建一棵全新的BST树。

       以上操作说明BST 的查找近似于折半查找，但其存储结构又类似与链表，所以是一种动态的查找表

   1.3 BST 的删除
        假设在BST上删除的节点为 p ，其双亲节点为 f，p是f的左孩子(右孩子可用同样的逻辑)，分三种情况讨论
        (1). 若节点p为叶子节点，由于删去叶子节点不破坏整棵树的结构，则只需修改其双亲节点的指针即可;
        (2). 若节点p只有左子树p_left或只有右子树p_right,此时只要令p_left或p_right成为其双亲节点f的左子树即可;
        (3). 若节点p的左子树和右子树均不为空。在删除节点p之前，中序遍历该BST得到的序列为 {...C_l,C,Q_l,Q,S_l,S,P,P_r,F ...}
             在删去p之后，为保持其他元素之间的位置不变，可以有两种做法：
                 (1). 令节点p的左子树为其双亲节点的左子树，而节点p的右子树为节点S的右子树(节点S为节点p在中序遍历序列的直接前驱节点)
                 (2). 另节点p的中序遍历的直接前驱节点S替代节点p，此时节点S在树中就有了两份，然后删除替代前的节点S，由于节点S只有左子树，
                      则只需要在删去节点S之后，令节点S_l为节点S的双亲节点的右子树即可。

   1.4 总结
       基本的BST在插入构建树的过程中或则在删除树的过程中，由于缺少旋转操作容易增加树的不平衡性，导致树空间的极大浪费，而平衡二叉树通过旋转操作
       来维持树的平衡性，减少树空间的浪费

2.AVL的原理
3.红黑树